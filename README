Project-level file layout
-------------------------
    * __init__.py, which will be empty. This file is required to tell Python that the directory is a Python module and can be imported (and imported from).
    * manage.py, which provides a number of convenience functions for working with the project.
    * settings.py, which will be the project settings file.
    * urls.py, which will be the project?s root URL configuration.


Application-level file layout
-----------------------------
    * __init__.py, which serves the same purpose as at the project level.
    * models.py, which should hold the application's model classes.

The __init__.py and models.py files (or, if you want to split up your models across multiple files, a directory called models which can act as a Python module) are required; without __init__.py, Python won't be able to import from the application, and Django is hard-wired to expect models in a file or module called models.

    * views.py, which is for any custom views the application wants to provide.
    * templatetags, contains custom template tags or filters, and it must contain a file named __init__.py so that it can be imported as a Python module.
    * tests.py/tests, contains test cases. The testing framework will also find any doctests in that module, but the preferred place for those is, of course, the docstrings of the classes or functions they're designed to test.
    * sql, provides custom SQL which will be executed immediately after your application is installed: the file names should be the same as the names of the models whose tables they'll operate on; for example, if you have an app named weblog containing a model named Entry, then the file sql/entry.sql inside the app?s directory can be used to modify or insert data into the entries table as soon as it?s been created.
    * management.py, provides custom Python functions which will run when the application is installed. Uses Django's internal dispatcher to connect your functions to the post_syncdb signal. 
    * forms.py, application defined custom manipulators or forms.
    * managers.py, contains multiple custom managers in the app.
    * context_processors.py, contains the definition any custom context processors.
    * signals.py, contains custom dispatcher signals.
    * feeds.py, contains classes and setting up any syndication feeds.
    * sitemaps.py, contains classes for SiteMaps.
    * middleware.py, contains middleware classes.
    * utils.py/utils, contains miscellaneous code which doesn't clearly go anywhere else.

About translations
------------------
Taken from the Django book (http://www.djangobook.com/en/1.0/chapter18/):

    Finally, you should give some thought to the structure of your translation files. If your applications need to be delivered to other users and will be used in other projects, you might want to use application-specific translations. But using application-specific translations and project translations could produce weird problems with make-messages. make-messages will traverse all directories below the current path and so might put message IDs into the project message file that are already in application message files.

    The easiest way out is to store applications that are not part of the project (and so carry their own translations) outside the project tree. That way, make-messages on the project level will only translate strings that are connected to your explicit project and not strings that are distributed independently.

From actual experience I know the project-wide translation files override those that are application-specific. Thus, if there is any application-specific translation that needs to be overwritten, maybe because of an error or a different context that changes its meaning, the entry in question should be put in the project-wide .po file. This entry should override or shadow the application-specific translation with the same key.-

Local vs. third-party applications
----------------------------------
Taken from 'Django Best Practices' (http://lincolnloop.com/django-best-practices/projects.html#local-applications)

    Local applications are Django applications that are domain-specific to your project. They typically live inside the project module and are so closely tied to your project, they would have little use outside of it.

    There are hundreds [1] of third-party open source Django applications available. Before you reinvent the wheel, make sure somebody hasnâ€™t already solved your problem by searching on Google or Django Packages. If you find something that will work do not put it your project code, instead add it to your pip requirements.
    [1] http://djangopackages.com/categories/apps/

